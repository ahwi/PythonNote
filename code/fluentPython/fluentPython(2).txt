#### 19.1.1 使用动态属性访问JSON类数据
实现一个近似字典的类来访问json数据，如:`feed['Schedule']['events'][40]['name']`
* 开源实现的库：AttrDict、addict
* 自己实现FrozeJSON类


示例 19-5 `explore0.py`：把一个JSON数据集转换成一个嵌套着FrozenJSON对象

```python
from collections import abc


class FrozenJSON:
    def __init__(self, mapping):
        self.__data = dict(mapping)

    def __getattr__(self, name):
        if hasattr(self.__data, name):
            return getattr(self.__data, name)
        else:
            return FrozenJSON.build(self.__data[name])

    @classmethod
    def build(cls, obj):
        if isinstance(obj, abc.Mapping):  # obj是映射，那就构建一个FrozenJSON对象
            return cls(obj)
        elif isinstance(obj, abc.MutableSequence):  # 如果是MutableSequence对象，必然是一个列表，因此把每个元素递归的传递给.build()方法，构建一个列表
            return [cls.build(item) for item in obj]
        else:
            return obj
```

示例 19-4 测试FrozenJSON类

```python
from explore0_19_5 import FrozenJSON
from osconfeed_19_2 import load


def test_fronze_json():
    raw_feed = load()
    feed = FrozenJSON(raw_feed)
    print(len(feed.Schedule.speakers))
    print(sorted(feed.Schedule.keys()))
    for key, value in sorted(feed.Schedule.items()):
        print('{:3} {}'.format(len(value), key))
    print(feed.Schedule.speakers[-1].name)
    talk = feed.Schedule.events[40]
    print(type(talk))
    print(talk.name)
    print(talk.speakers)
    print(talk.flavor)


if __name__ == "__main__":
    test_fronze_json()
```

#### 19.1.2 处理无效属性名

FrozenJSON类有个缺陷：没有对名称为Python关键字的属性做特殊处理，如下所示:

```python
m = {"name": "jack",
	 "class": "Jack"
	 }
f = FrozenJSON(m)
print(f.name)
print(f.class)
	
-------------
结果：
    print(f.class)
                ^
SyntaxError: invalid syntax
```

虽然可以使用`getattr(f, 'class')`来获取`class`属性，但是违背了设计FrozenJSON的设计初衷。

只能在关键字后面加一个下划线来访问:
```python
m = {"name": "jack",
	 "class": "Jack"
	 }
f = FrozenJSON(m)
print(f.name)
print(f.class_)

# 结果：
jack
Jack
```

需要修改`__init__`方法：
示例 19-6 explore1.py：在名称为 Python 关键字的属性后面加上 

```python
    def __init__(self, mapping):
        self.__data = dict()
        for key, value in mapping.items():
            if keyword.iskeyword(key):
                key += '_'
            self.__data[key] = value
```

除了关键字，还会有对象中的键不是有效的Python标识符的情况：

```python
>>> x = FrozenJSON({'2be':'or not'})
>>> x.2be
File "<stdin>", line 1
x.2be
^
SyntaxError: invalid syntax
```
有两种解决方法：
* 抛出异常
* 把无效的键换成通用名称，例如attr_0、attr_1，等等。
为了简单起见，这边忽略这个问题

#### 19.1.3 使用`__new__`方法以灵活的方式创建对象

* 用于构建实例的特殊方法`__new__`
* `__new__`是一个类方法，使用格式方式处理，因此不必使用`@classmethod`装饰器
* `__new__`必须返回一个实例，返回的实例会作为第一个参数（即self）传递给`__init__`方法 
* `__init__`其实是"初始化方法"，因为调用`__init__`方法时要传入实例，而且禁止返回任何值。真正的构造方法是`__new__`
* 从`__new__`到`__init__`是最常见的，但不是唯一的。`__new__`方法可以返回其他类的实例，此时，解释器不会调用`__init__`方法
	python构建对象过程的伪码表示：
	```python
	# 构建对象的伪代码
	def object_maker(the_class, some_arg):
        new_object = the_class.__new__(some_arg)
        if isinstance(new_object, the_class):
            the_class.__init__(new_object, some_arg)
        return new_object
		
    # 下述两个语句的作用基本等效
    x = Foo('bar')
    x = object_maker(Foo, 'bar')
	```
	
	
### 第21章 类元编程
* 类元变成是指在运行时创建或定制类的技艺
* 在python中，类是一等对象，可以使用函数新建类，而无需使用class关键字
* 类装饰器也是函数，不过能够审查、修改，甚至把被装饰的类替换成其他类
* 元类是类元编程最高级的工具：使用元类可以创建具有某种特质的全新类种，例如抽象基类。

#### 21.1 类工厂函数

```python
λ python3 i record_factory_21-2.pyy
>>> Dog = record_factory('Dog', 'name weight owner')
>>> rex = Dog('rex', 30, 'Bob')
>>> rex
Dog(name='rex', weight=30, owner='Bob')
>>> name, weight, _ = rex
>>> name, weight
('rex', 30)
>>> "{2}'s dog weiths {1}.kg".format(*rex)
"Bob's dog weiths 30.kg"
>>> rex.weight = 32
>>> rex
Dog(name='rex', weight=32, owner='Bob')
>>> Dog.__mro__
(<class '__main__.Dog'>, <class 'object'>)
```

#### 21.2 定制描述符的类装饰器
#### 21.3 导入时和运行时比较
#### 21.4 元类基础知识
#### 21.5 定制描述符的元类
#### 21.6 元类的特殊方法`__prepare__`
#### 21.7 类作为对象